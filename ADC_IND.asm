ORG 1070H
DB 01H, 02H, 04H, 08H, 10H, 20H, 40H, 80H	;Занесение в ПЗУ масок для опрделения наличия бита

ORG 1080H
DB 02H, 04H, 08H, 06H, 01H, 03H, 05H, 01H	;Занесение в ПЗУ кодов значений сотых

ORG 1090H
DB 00H, 00H, 00H, 01H, 03H, 06H, 02H, 05H	;Занесение в ПЗУ кодов значений десятых

ORG 10A0H
DB 00H, 00H, 00H, 00H, 00H, 00H, 01H, 02H	;Занесение в ПЗУ кодов значений единиц


;Установка векторов прерываний
ORG 0H
JMP main						; Переход к основной программе

ORG 0003H
JMP int0_interrupt				; Переход к подпрограмме "Обработка внешнего прерывания от АЦП"

ORG 000BH		
CALL timer0						; Переход к подпрограмме "Обработка прерывания от таймера Т0"

ORG 0013H
RETI

ORG 001BH
RETI

ORG 0023H
RETI

ORG 0030H

;=================================Основная программа===========================================================================
main:
CLR P3.6						; Установка входа WR АЦП в логический ноль
CALL t0init						; Вызов подпрограммы "Инициализация таймера Т0"
CALL adcinit					; Вызов подпрограммы "Инициализация АЦП"
SETB RS1						; Выбор 2-го банка регистров
MOV R7, #0						; Очистка R7 
CLR RS1							; Выбор 0-го банка регистров

;---------------------------------Основной цикл обработки кода---------------------------------------------------------------------------------
sled_znach:
MOV DPH, #10H					; Загрузка в DPH старшего бита адреса всех кодов из ПЗУ
CLR A							; Очистка А
MOV R7, 60H						; Пересылка кода из АЦП в R7
MOV R6 ,#00H					; Очистка R6		- регистр масок			
MOV R5, #00H					; Очистка R5 - регистр суммы
MOV R4, #01H					; Занесение в R4 кода для определения наличия нулевого разряда 
MOV B,  #01H					; Занесение в В кода для определения наличия нулевого разряда 	
MOV R3, #70H					; Загрузка в R3 младшего бита адреса кодов масок
MOV R2, #80H					; Загрузка в R2 младшего бита адреса кодов значений разрядов сотых
MOV R1, #00H					; Очистка R0	

sled_bit:
CJNE R1, #18H, desyatye			; Если были получены промежуточные значения, то дальше, иначе к обработке оставшихся битов
MOV 72H, R5						; Занесение в ЯП ОП 72Н суммы единиц
JMP modifik						; Переход к преобразованию промежуточных значений в окончательный результат

desyatye:						
CJNE R1, #10H,sotye				; Если была получена сумма десятых, то дальше, иначе к обработке десятых
MOV 71H, R5						; Занесение в ЯП ОП 71Н суммы десятых
MOV R5, #00						; Очистка R0	- результата сложения
MOV R3, #70H					; Обновления адреса масок
MOV R2, #0A0H					; Обновление адреса значений разрядов единиц

sotye:
CJNE R1, #08H, loop				; Если была получена сумма сотых, то дальше, иначе к обработке сотых
MOV 70H, R5						; Занесение в ЯП ОП 70Н суммы сотых
MOV R5, #00						; Очистка R0	- результата сложения
MOV R3, #70H					; Обновления адреса масок
MOV R2, #90H					; Обновление адреса значений разрядов десятых

;.................................Цикл получения суммы сотых/десятых/единиц..................................................................
loop:
MOV DPL, R3						; Загрузка в DPL младшей части адреса кодов масок
MOVC A, @A+DPTR					; Загрузка в А кода маски
INC R3							; Увеличение адреса кода маски на 1
MOV R6, A						; Пересылка маски в R6
MOV A, R7						; Пересылка кода АЦП в А
ANL A, R6						; Логическое И над кодом АЦП и маски

XCH A, R4						; Обмен содержиомого А и R4 для дальнейшего определения наличия бита
CLR C							; Очистка С
SUBB A, R4						; Определение наличия бита в разряде

JNZ ne_odin						; Если при вычитании из маски разряда текущего бита разряда получился ноль, значит бит присутствует, инае его нет
MOV DPL, R2						; Загрузка в DPL младшей части адреса кодов масок
CLR A							; Загрузка в DPL младшей части адреса кодов значений сотых/десятых/единиц
MOVC A, @A+DPTR					; Загрузка в А кода значения 
INC R2							; Увеличение адреса кода значений на 1
ADD A, R5						; Слжение текущего значения разряда с предыдущим
MOV R5, A						; Пересылка суммы значений в R5

MOV A, B						; Пересылка копии значения R4 в А
RL A							; Сдвиг А (умножение на 2) маски для последующего определения следующего бита
MOV R4, A						; Пересылка полученной макси в R4
MOV B, A						; Копирование маски в В
CLR A							; Очистка маски

INC R1							; Инкремент количества обработанных разрядов
JMP sled_bit					; Переход к обработке следующего бита

ne_odin:						; Если бит не равен 1
INC R2							; Увеличение адреса кода значений на 1

MOV A, B						; Пересылка копии значения R4 в А
RL A							; Сдвиг А (умножение на 2) маски для последующего определения следующего бита
MOV R4 ,A						; Пересылка полученной макси в R4
MOV B, A						; Копирование маски в В
CLR A							; Очистка маски

INC R1							; Инкремент количества обработанных разрядов
JMP sled_bit					; Переход к обработке следующего бита
;..............................................................................................................................................

;++++++++++++++++++++++++++++++++ Преобразование полученной суммы в конечное значение++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
modifik:
CLR A							; Очистка A
MOV R7, #0						; Очистка R7
MOV R6, #0						; Очистка R6
MOV R0, #70H					; Занесение в R0 адреса ЯП ОП, содержащей сумму сотых
MOV A, @R0						; Пересылка в А суммы сотых по адресу из R0
CLR C							; Очистка С

povtor:
INC R7							; Увеличение количества переполнения разряда сотых
SUBB A, #10						; Вычитание из суммы сотых 10
JNC povtor						; Если при вычитании не получилось отрицательное число, то повтор 

DEC R7							; Декремент количества переполнения разряда сотых (был инкрементирован лишний раз)
ADD A, #10						; Сложение суммы сотых с 10 (было вычтено лишний раз)
MOV 73H, A						; Пересылка в ЯП ОП 73Н полученного кода сотых
INC R0							; Инкремент R0 - занесение в R0 адреса ЯП ОП, содержащей сумму десятых
MOV A, @R0						; Пересылка в А суммы десятых по адресу из R0
ADD A, R7						; Сложение количества переполнения при сложении сотых с суммой десятых

povtor2:						; Увеличение количества переполнения разряда десятых 
INC R6							; Вычитание из суммы десятых 10
SUBB A, #10						; Если при вычитании не получилось отрицательное число, то повтор
JNC povtor2						;

DEC R6							; Декремент количества переполнения разряда десятых(был инкрементирован лишний раз)
ADD A, #10						; Сложение суммы десятых с 10 (было вычтено лишний раз)
MOV 74H, A						; Пересылка в ЯП ОП 74Н полученного кода десятых
INC R0							; Инкремент R0 - занесение в R0 адреса ЯП ОП, содержащей сумму единиц
MOV A, @R0						; Пересылка в А суммы единиц по адресу из R0
ADD A, R6						; Сложение количества переполнения при сложении десятых с суммой единиц
MOV 75H, A						; Пересылка в ЯП ОП 75Н полученного кода сотых
MOV R6, #0						; Очистка R6 - количества переполнения десятых

JMP sled_znach					; Переход к обработке следующего знаечения
;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;-----------------------------------------------------------------------------------------------------------------------------------------------

;=================================Подпрограмма "Обработка прерывания от таймера Т0"==========================================
timer0:
PUSH PSW						; Сохранение в сиек значения содержимого регистра PSW для невозможности изменения в процессе выполнния подпрограммы
CALL t0init						; Вызов подпрограммы инициализации таймера
SETB RS1						; Выбор 2-ого банка регистров

CJNE R7, #0, ind1				; Если на индикатор 0 не было выведено значение, то вывести. Иначе на следующий
CLR P3.4						; |Выбор индикатора №0
CLR P3.3						; |Выбор индикатора №0
INC R7							; Инкремент R7 - был осуществлен вывод на индикатор №0
MOV R1, 73H						; Пересылка значения сотых в R1
CJNE R1, #0, ne_0				; Если значение равно нулю, вывод нуля. Иначе к выводу единицы
MOV P1, #11000000B				; Пересылка в порт 1 кода для вывода нуля
JMP vozvr						; Переход к процессу возвращения из прерывания 
ne_0:
CJNE R1, #1, ne_1
MOV P1, #11111001B
JMP vozvr 
ne_1:
CJNE R1, #2, ne_2
MOV P1, #10100100B
JMP vozvr 
ne_2:
CJNE R1, #3, ne_3
MOV P1, #10110000B
JMP vozvr 
ne_3:
CJNE R1, #4, ne_4
MOV P1, #10011001B
JMP vozvr 
ne_4:
CJNE R1, #5, ne_5
MOV P1, #10010010B
JMP vozvr 
ne_5:
CJNE R1, #6, ne_6
MOV P1, #10000010B
JMP vozvr 
ne_6:
CJNE R1, #7, ne_7
MOV P1, #11111000
JMP vozvr 
ne_7:
CJNE R1, #8, ne_8
MOV P1, #10000000B
JMP vozvr
ne_8:
CJNE R1, #9, vozvr1
MOV P1, #10010000B
JMP vozvr
vozvr1:
JMP vozvr

ind1:
CJNE R7, #1, ind2					; Если на индикатор 1 не было выведено значение, то вывести. Иначе на следующий
CLR P3.4							; |Выбор индикатора №1
SETB P3.3							; |Выбор индикатора №1
INC R7								; Инкремент R7 - был осуществлен вывод на индикатор №1
MOV R1, 74H							; Пересылка значения десятых в R1
CJNE R1, #0, ne_00
MOV P1, #11000000B
JMP vozvr 
ne_00:
CJNE R1, #1, ne_11
MOV P1, #11111001B
JMP vozvr 
ne_11:
CJNE R1, #2, ne_22
MOV P1, #10100100B
JMP vozvr 
ne_22:
CJNE R1, #3, ne_33
MOV P1, #10110000B
JMP vozvr 
ne_33:
CJNE R1, #4, ne_44
MOV P1, #10011001B
JMP vozvr 
ne_44:
CJNE R1, #5, ne_55
MOV P1, #10010010B
JMP vozvr 
ne_55:
CJNE R1, #6, ne_66
MOV P1, #10000010B
JMP vozvr 
ne_66:
CJNE R1, #7, ne_77
MOV P1, #11111000
JMP vozvr 
ne_77:
CJNE R1, #8, ne_88
MOV P1, #10000000B
JMP vozvr
ne_88:
CJNE R1, #9, vozvr
MOV P1, #10010000B
JMP vozvr


ind2:									; Если на индикатор 2 не было выведено значение, то вывести. Иначе на следующий
CJNE R7, #2, vozvr						; |Выбор индикатора №1
SETB P3.4								; |Выбор индикатора №2
CLR P3.3								; Инкремент R7 - был осуществлен вывод на индикатор №2
MOV R1, 75H								; Пересылка значения единиц в R1
INC R7
CJNE R1, #0, ne_000
MOV P1, #01000000B
JMP vozvr 
ne_000:
CJNE R1, #1, ne_111
MOV P1, #01111001B
JMP vozvr 
ne_111:
CJNE R1, #2, ne_222
MOV P1, #00100100B
JMP vozvr 
ne_222:
CJNE R1, #3, ne_333
MOV P1, #00110000B
JMP vozvr 
ne_333:
CJNE R1, #4, ne_444
MOV P1, #00011001B
JMP vozvr 
ne_444:
CJNE R1, #5, ne_555
MOV P1, #00010010B
JMP vozvr 
ne_555:
CJNE R1, #6, ne_66
MOV P1, #00000010B
JMP vozvr 
ne_666:
CJNE R1, #7, ne_777
MOV P1, #11111000
JMP vozvr 
ne_777:
CJNE R1, #8, ne_888
MOV P1, #00000000B
JMP vozvr
ne_888:
CJNE R1, #9, vozvr
MOV P1, #00010000B
JMP vozvr

vozvr:
CJNE R7, #3, ne_vse_vivedeno	; Если значение было выведено на все индикаторы, очистка счетчиков индикаторов
MOV R7, #0						; Очистка счетчика индикаторов
ne_vse_vivedeno:				
MOV R1, #0						; Очистка выведенного значения
CLR RS1							; Выбор 0-го банка регистров
POP PSW							; Извлечение из стека значения регистра PSW
RETI							; Возвращение к основной программе


;=================================Подпрограмма "Инициализация таймера Т0"==================================================
t0init:
MOV TMOD, #00000001B			; Выбор режима работы таймера T0 - 16-битный таймер от внутреннего источника
SETB TR0						; Настройка статуса таймера - запус таймера Т0

MOV TH0, #0F6H					; |
MOV TL0, #03BH					; |Занесение в таймер T0 оптимальной задержки индикации - F63BH 

SETB EA							; Снятие блокировки прерывания
SETB ET0						; Бит разрешения прерывания от таймера T0.
RET								; Возвращение к основной программе



;=================================Подпрограмма "Обработка внешнего прерывания от АЦП"======================================
int0_interrupt:
CLR P3.5						; Установка входа RD АЦП в логическую единицу (для возможности чтения с АЦП)
NOP
MOV 60H,P2						; Чтение кода с АЦП
NOP
SETB P3.5						; Подтверждение приема данных

CALL adcinit					; Вызов подпрограммы инициализации АЦП
RETI							; Возвращение к основной программе

;=================================Подпрограмма "Инициализация АЦП"========================================================
adcinit:
SETB IT0               		    ; Установка типа прерывания - IT0   
SETB EX0						; Разрешение внешнего прерывания IT0

SETB P3.6              		    ; Установка входа WR АЦП в логическую единицу - Начало процесса преобразования
NOP								; Пустая команда
NOP								; Пустая команда
CLR P3.6						; Установка входа WR АЦП в логический ноль 
RET								; Возвращение к основной программе
